import { eq, and, desc, sql } from 'drizzle-orm';
import { getDb } from '@ctt/shared/db';
import { invoices, invoiceLineItems, timeEntries, rateTiers, clients, users } from '@ctt/shared/schema';

export interface GenerateInvoiceOptions {
  clientId: string;
  dateFrom?: string;
  dateTo?: string;
  dateDue?: string;
  notes?: string;
  isAutoGenerated?: boolean;
}

export interface GenerateInvoiceResult {
  invoice: typeof invoices.$inferSelect;
  lineItemCount: number;
  totalHours: number;
  totalAmount: number;
}

/**
 * Generate an invoice from unbilled time entries for a client.
 * Returns null if no unbilled entries are found in the date range.
 */
export async function generateInvoice(options: GenerateInvoiceOptions): Promise<GenerateInvoiceResult | null> {
  const db = await getDb();
  const { clientId, dateFrom, dateTo, dateDue, notes, isAutoGenerated = false } = options;

  // Get unbilled entries for this client
  const conditions = [
    eq(timeEntries.clientId, clientId),
    eq(timeEntries.isBilled, false),
  ];
  if (dateFrom) conditions.push(sql`${timeEntries.date} >= ${dateFrom}`);
  if (dateTo) conditions.push(sql`${timeEntries.date} <= ${dateTo}`);

  const unbilled = await db.select({
    entry: timeEntries,
    rate: rateTiers,
    tech: users,
  })
    .from(timeEntries)
    .innerJoin(rateTiers, eq(timeEntries.rateTierId, rateTiers.id))
    .innerJoin(users, eq(timeEntries.techId, users.id))
    .where(and(...conditions));

  if (unbilled.length === 0) {
    return null;
  }

  // Generate sequential invoice number per client (e.g., ACM-0001, ACM-0002)
  const [client] = await db.select().from(clients).where(eq(clients.id, clientId));
  const prefix = (client?.name || 'INV').substring(0, 3).toUpperCase();
  const existing = await db.select({ invoiceNumber: invoices.invoiceNumber })
    .from(invoices)
    .where(eq(invoices.clientId, clientId))
    .orderBy(desc(invoices.createdAt));
  let nextNum = 1;
  for (const row of existing) {
    const match = row.invoiceNumber.match(/-(\d+)$/);
    if (match) {
      const num = parseInt(match[1], 10);
      if (num >= nextNum) nextNum = num + 1;
    }
  }
  const invoiceNumber = `${prefix}-${String(nextNum).padStart(4, '0')}`;

  // Create the invoice
  const [invoice] = await db.insert(invoices).values({
    clientId,
    invoiceNumber,
    dateIssued: new Date().toISOString().split('T')[0],
    dateDue: dateDue || undefined,
    status: 'draft',
    notes: notes || undefined,
    isAutoGenerated,
  }).returning();

  let totalHours = 0;
  let totalAmount = 0;

  // Create line items from entries
  for (const { entry, rate, tech } of unbilled) {
    // Format date as M/D (e.g., "2/18")
    const d = new Date(entry.date + 'T00:00:00');
    const shortDate = `${d.getMonth() + 1}/${d.getDate()}`;
    const techName = tech.displayName || tech.username;
    const note = entry.notes || '';
    const description = note
      ? `${note} (${techName}) (${shortDate})`
      : `(${techName}) (${shortDate})`;

    await db.insert(invoiceLineItems).values({
      invoiceId: invoice.id,
      timeEntryId: entry.id,
      description,
      hours: entry.hours,
      rate: rate.amount,
    });

    totalHours += Number(entry.hours);
    totalAmount += Number(entry.hours) * Number(rate.amount);

    // Mark entry as billed
    await db.update(timeEntries)
      .set({ isBilled: true, invoiceId: invoice.id, updatedAt: new Date() })
      .where(eq(timeEntries.id, entry.id));
  }

  return {
    invoice,
    lineItemCount: unbilled.length,
    totalHours,
    totalAmount,
  };
}

/**
 * Get the total unbilled hours for a client within a date range.
 */
export async function getUnbilledHours(clientId: string, dateFrom?: string, dateTo?: string): Promise<number> {
  const db = await getDb();
  const conditions = [
    eq(timeEntries.clientId, clientId),
    eq(timeEntries.isBilled, false),
  ];
  if (dateFrom) conditions.push(sql`${timeEntries.date} >= ${dateFrom}`);
  if (dateTo) conditions.push(sql`${timeEntries.date} <= ${dateTo}`);

  const result = await db.select({
    totalHours: sql<string>`COALESCE(SUM(${timeEntries.hours}), 0)`,
  })
    .from(timeEntries)
    .where(and(...conditions));

  return Number(result[0]?.totalHours || 0);
}
